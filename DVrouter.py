####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

import json
from router import Router
from packet import Packet

INFINITY = 16

class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.routing_table = {addr: (addr, 0)} # des -> (nx_hop, cost)
        self.neighbors = {} # hang xom
        self.distance_vectors = {} # luu vector


    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            dst = packet.dst_addr
            if dst in self.routing_table:
                next_hop, _ = self.routing_table[dst]
                for p, (neighbor, _) in self.neighbors.items():
                    if neighbor == next_hop:
                        self.send(p, packet)
                        break
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            neighbor = packet.src_addr
            content = json.loads(packet.content)
            old_vector = self.distance_vectors.get(neighbor, {})
            if content != old_vector:
                self.distance_vectors[neighbor] = content
                self.recompute_routing_table()

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        self.neighbors[port] = (endpoint, cost)
        self.distance_vectors[endpoint] = {endpoint: 0}  # nó tự đến nó

        updated = False
        if endpoint not in self.routing_table or cost < self.routing_table[endpoint][1]:
            self.routing_table[endpoint] = (endpoint, cost)
            updated = True

        if updated:
            self.send_distance_vector()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        if port not in self.neighbors:
            return

        neighbor, _ = self.neighbors[port]
        del self.neighbors[port]
        if neighbor in self.distance_vectors:
            del self.distance_vectors[neighbor]

        to_delete = [dst for dst, (nh, _) in self.routing_table.items() if nh == neighbor]
        for dst in to_delete:
            del self.routing_table[dst]

        self.recompute_routing_table()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors
            self.send_distance_vector()
    
    def send_distance_vector(self):
        vector = {dst: cost for dst, (_, cost) in self.routing_table.items()}
        content = json.dumps(vector)

        for port, (neighbor, _) in self.neighbors.items():
            packet = Packet(Packet.ROUTING, self.addr, neighbor, content)
            self.send(port, packet)

    def recompute_routing_table(self):
        new_table = {self.addr: (self.addr, 0)}

        for port, (neighbor, cost_to_neighbor) in self.neighbors.items():
            neighbor_vector = self.distance_vectors.get(neighbor, {})
            for dest, neighbor_cost in neighbor_vector.items():
                if dest == self.addr:
                    continue
                total_cost = neighbor_cost + cost_to_neighbor
                if total_cost >= INFINITY:
                    continue
                if dest not in new_table or total_cost < new_table[dest][1]:
                    new_table[dest] = (neighbor, total_cost)

        if new_table != self.routing_table:
            self.routing_table = new_table
            self.send_distance_vector()

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        lines = [f"Router {self.addr} Routing Table:"]
        for dst, (nxt, cost) in sorted(self.routing_table.items()):
            lines.append(f"  {dst} → {nxt}, cost {cost}")
        return "\n".join(lines)
