####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import json
INFINITY = 16


class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        #   add your own class fields and initialization code here
        self.forwarding_table = {}
        self.distance_vector = {addr: 0}
        self.distance_vector_from_neighbors = {}
        self.neighbors = {} 

    def broadcast_distance_vector(self):
        content = json.dumps(self.distance_vector)
        for port, (neighbor, _) in self.neighbors.items():
            if 'A' <= neighbor < 'Z':
                self.send(port, Packet(Packet.ROUTING, self.addr, neighbor, content=content))

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dst_addr in self.forwarding_table:
                self.send(self.forwarding_table[packet.dst_addr], packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            neighbor = packet.src_addr
            neighbor_distance_vector = json.loads(packet.content)
            # If the received distance vector is different
            if neighbor not in self.distance_vector_from_neighbors or self.distance_vector_from_neighbors[neighbor] != neighbor_distance_vector:
            #   update the local copy of the distance vector
                self.distance_vector_from_neighbors[neighbor] = neighbor_distance_vector
            #   update the distance vector of this router
            #   update the forwarding table
                self.update_forwarding_table()
            #   broadcast the distance vector of this router to neighbors
                self.broadcast_distance_vector()

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        self.neighbors[port] = (endpoint, cost)
        #   update the distance vector of this router
        self.distance_vector_from_neighbors[endpoint] = {}
        if endpoint not in self.distance_vector or cost < self.distance_vector[endpoint]:
            self.distance_vector[endpoint] = cost
        #   update the forwarding table
            self.forwarding_table[endpoint] = port
        #   broadcast the distance vector of this router to neighbors
        self.broadcast_distance_vector()

    def handle_remove_link(self, port):
        """Handle removed link."""
        if port in self.neighbors:
            neighbor, cost = self.neighbors.pop(port)
        #   update the distance vector of this router
            if neighbor in self.distance_vector:
                del self.distance_vector[neighbor]
        #   update the forwarding table
            self.update_forwarding_table()
        #   broadcast the distance vector of this router to neighbors
            self.broadcast_distance_vector()

    def find_port_by_endpoint(self, endpoint):
        for port, (neighbor, _) in self.neighbors.items():
            if neighbor == endpoint:
                return port
        return None

    def update_forwarding_table(self):
        new_distance_vector = {self.addr: 0}
        new_forwarding_table = {}
        for port, (neighbor, cost) in self.neighbors.items():
            if neighbor not in new_distance_vector or cost < new_distance_vector[neighbor]:
                new_distance_vector[neighbor] = cost
                new_forwarding_table[neighbor] = port
        
        for neighbor, distance_vector in self.distance_vector_from_neighbors.items():
            port = self.find_port_by_endpoint(neighbor)
            if port is None:
                continue
            cost_tmp = self.neighbors[port][1]
            for dst_addr, cost in distance_vector.items():
                if dst_addr == self.addr:
                    continue
                total_cost = cost_tmp + cost
                if total_cost >= INFINITY:
                    continue
                if dst_addr not in new_distance_vector or total_cost < new_distance_vector[dst_addr]:
                    new_distance_vector[dst_addr] = cost_tmp + cost
                    new_forwarding_table[dst_addr] = port
        self.distance_vector = new_distance_vector
        self.forwarding_table = new_forwarding_table

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            #   broadcast the distance vector of this router to neighbors
            self.broadcast_distance_vector()

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"""DVrouter(addr={self.addr}, 
        dv={self.distance_vector}, 
        forwarding_table={self.forwarding_table}),
        neighbors={self.neighbors})"""